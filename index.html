<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPUB endnotes to parenthetical</title>
    <meta name="description" content="Преобразование концевых сносок в EPUB в текст в скобках">
    <meta name="theme-color" content="#ffffff">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="data:image/svg+xml,%3Csvg width='33' height='18' viewBox='0 0 33 18' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 18L3.0532 0H9.05783L8.79067 1.54071H4.59252L2.06091 16.4593H6.25906L5.9919 18H0Z' fill='black'/%3E%3Cpath d='M33 0L29.9468 18H23.9422L24.2093 16.4593H28.4075L30.9264 1.54071H26.7282L26.9954 0L33 0Z' fill='black'/%3E%3Cpath d='M15.266 17.6994L5.80108 14.7683L7.70933 2.94363L16.8944 5.78706L27.3007 2.86848L25.367 14.856L15.266 17.6994ZM7.95104 13.4656L15.2914 15.7328L23.675 13.3779L24.9472 5.4739L16.8689 7.74113L9.24865 5.38622L7.95104 13.453V13.4656Z' fill='black'/%3E%3Cpath d='M15.9382 6.62474L14.3258 16.5698L16.2102 16.866L17.8226 6.92094L15.9382 6.62474Z' fill='black'/%3E%3C/svg%3E">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="EPUB endnotes">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            width: 100%;
        }
        
        body {
            font-family: 'IBM Plex Mono', monospace;
            background: #ffffff;
            color: #000000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px 24px;
        }
        
        .container {
            min-width: 280px;
            max-width: 680px;
            width: 100%;
            text-align: left;
        }
        
        .logo {
            width: 32px;
            height: 17.45px;
            margin-bottom: 48px;
        }
        
        .logo svg {
            width: 100%;
            height: 100%;
        }
        
        .description {
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 48px;
        }
        
        .description p {
            margin-bottom: 16px;
        }
        
        .example {
            margin: 32px 0;
            padding-left: 32px;
        }
        
        .example-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5em;
            color: #A9A9A9;
            margin-bottom: 12px;
            font-weight: 400;
        }
        
        .example-text {
            font-size: 14px;
            color: #A9A9A9;
            line-height: 1.8;
        }
        
        .example-text i {
            font-style: italic;
        }
        
        .upload-button {
            width: 220px;
            height: 64px;
            padding: 0;
            background: #000000;
            color: #ffffff;
            border: none;
            border-radius: 100px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 16px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5em;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 48px;
            box-shadow: 0 0 0 rgba(0, 0, 0, 0);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .upload-button:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
        }
        
        .upload-button:active {
            transform: scale(0.98);
        }
        
        .upload-button.drag-over {
            transform: scale(1.02);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
        }
        
        .upload-button.processing {
            background: #666666;
            cursor: wait;
            pointer-events: none;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .status {
            margin-top: 24px;
            font-size: 14px;
            text-align: center;
            color: #A9A9A9;
        }
        
        .status.error {
            color: #ff0000;
        }
        
        @media (max-width: 640px) {
            body {
                padding: 40px 64px;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">
            <svg width="33" height="18" viewBox="0 0 33 18" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 18L3.0532 0H9.05783L8.79067 1.54071H4.59252L2.06091 16.4593H6.25906L5.9919 18H0Z" fill="black"/>
                <path d="M33 0L29.9468 18H23.9422L24.2093 16.4593H28.4075L30.9264 1.54071H26.7282L26.9954 0L33 0Z" fill="black"/>
                <path d="M15.266 17.6994L5.80108 14.7683L7.70933 2.94363L16.8944 5.78706L27.3007 2.86848L25.367 14.856L15.266 17.6994ZM7.95104 13.4656L15.2914 15.7328L23.675 13.3779L24.9472 5.4739L16.8689 7.74113L9.24865 5.38622L7.95104 13.453V13.4656Z" fill="black"/>
                <path d="M15.9382 6.62474L14.3258 16.5698L16.2102 16.866L17.8226 6.92094L15.9382 6.62474Z" fill="black"/>
            </svg>
        </div>
        
        <div class="description">
            <p id="desc1"></p>
            <p id="desc2"></p>
            <p id="desc3"></p>
        </div>

        <div class="example">
            <div class="example-label" id="labelBefore"></div>
            <div class="example-text" id="exampleBefore"></div>
        </div>

        <div class="example">
            <div class="example-label" id="labelAfter"></div>
            <div class="example-text" id="exampleAfter"></div>
        </div>

        <div class="description">
            <p id="desc4"></p>
        </div>

        <button class="upload-button" id="uploadButton">Загрузить</button>
        <input type="file" id="fileInput" accept=".epub" />
        
        <div id="statusContainer"></div>
    </div>

    <script>
        // Локализация
        const translations = {
            ru: {
                description1: 'Многие электронные книги содержат ссылки на\u00A0примечания в\u00A0конце книги\u00A0— [1], [2] и\u00A0так далее.',
                description2: 'На\u00A0читалках без сенсорного экрана неудобно переходить по\u00A0этим ссылкам и\u00A0возвращаться обратно к\u00A0тексту.',
                description3: 'Этот сервис автоматически добавляет текст каждого примечания прямо в\u00A0книгу, рядом с\u00A0цифрой-ссылкой.',
                labelBefore: 'Было',
                exampleBefore: '...в\u00A0Перу[1] сплели мост...',
                labelAfter: 'Стало',
                exampleAfter: '...в\u00A0Перу[1] <i>[страна в\u00A0Южной Америке]</i> сплели мост...',
                description4: 'Загрузите EPUB файл, и\u00A0получите новый файл, в\u00A0котором все примечания встроены в\u00A0текст курсивом в\u00A0квадратных скобках.',
                btnUpload: 'Загрузить',
                btnDownload: 'Скачать',
                btnProcessing: 'Обработка...',
                statusProcessing: 'Обработка файла...',
                statusSearching: 'Поиск примечаний...',
                statusFound: 'Найдено {count} примечаний',
                statusCreating: 'Создание файла...',
                statusDone: 'Готово! Обработано {count} ссылок',
                statusDownloaded: 'Файл скачан',
                errorFormat: 'Только EPUB файлы',
                errorGeneric: 'Ошибка: {message}'
            },
            en: {
                description1: 'Many ebooks contain links to\u00A0endnotes at\u00A0the end of\u00A0the book\u00A0— [1], [2] and\u00A0so\u00A0on.',
                description2: 'On\u00A0e-readers without touchscreens, it\u00A0is\u00A0inconvenient to\u00A0follow these links and\u00A0return back to\u00A0the text.',
                description3: 'This service automatically adds the text of\u00A0each note directly into the book, next to\u00A0the reference number.',
                labelBefore: 'Before',
                exampleBefore: '...in\u00A0Peru[1] they built a\u00A0bridge...',
                labelAfter: 'After',
                exampleAfter: '...in\u00A0Peru[1] <i>[a country in\u00A0South America]</i> they built a\u00A0bridge...',
                description4: 'Upload an\u00A0EPUB file and\u00A0get a\u00A0new file with all notes embedded in\u00A0the text in\u00A0italics within square brackets.',
                btnUpload: 'Upload',
                btnDownload: 'Download',
                btnProcessing: 'Processing...',
                statusProcessing: 'Processing file...',
                statusSearching: 'Searching for notes...',
                statusFound: 'Found {count} notes',
                statusCreating: 'Creating file...',
                statusDone: 'Done! Processed {count} links',
                statusDownloaded: 'File downloaded',
                errorFormat: 'EPUB files only',
                errorGeneric: 'Error: {message}'
            }
        };

        // Определение языка
        function detectLanguage() {
            const userLang = navigator.language || navigator.userLanguage;
            return userLang.toLowerCase().startsWith('ru') ? 'ru' : 'en';
        }

        const currentLang = detectLanguage();
        const t = translations[currentLang];

        // Применение переводов
        function applyTranslations() {
            document.getElementById('desc1').innerHTML = t.description1;
            document.getElementById('desc2').innerHTML = t.description2;
            document.getElementById('desc3').innerHTML = t.description3;
            document.getElementById('labelBefore').textContent = t.labelBefore;
            document.getElementById('exampleBefore').innerHTML = t.exampleBefore;
            document.getElementById('labelAfter').textContent = t.labelAfter;
            document.getElementById('exampleAfter').innerHTML = t.exampleAfter;
            document.getElementById('desc4').innerHTML = t.description4;
            uploadButton.textContent = t.btnUpload;
        }

        const uploadButton = document.getElementById('uploadButton');
        const fileInput = document.getElementById('fileInput');
        const statusContainer = document.getElementById('statusContainer');
        const globalFootnotes = new Map();
        let processedBlob = null;
        let originalFilename = '';

        // Применяем переводы при загрузке
        applyTranslations();

        uploadButton.addEventListener('click', () => {
            if (processedBlob) {
                downloadFile();
            } else {
                fileInput.click();
            }
        });
        
        uploadButton.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (!processedBlob) {
                uploadButton.classList.add('drag-over');
            }
        });
        
        uploadButton.addEventListener('dragleave', () => {
            uploadButton.classList.remove('drag-over');
        });
        
        uploadButton.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadButton.classList.remove('drag-over');
            if (!processedBlob) {
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        function downloadFile() {
            if (!processedBlob) return;
            
            const url = URL.createObjectURL(processedBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = originalFilename.replace('.epub', '_converted.epub');
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showStatus(t.statusDownloaded);
        }

        function showStatus(message, type = '') {
            statusContainer.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function stripHtmlTags(html) {
            return html
                .replace(/<br\s*\/?>/gi, ' ')
                .replace(/<\/p>/gi, ' ')
                .replace(/<[^>]+>/g, '')
                .replace(/\s+/g, ' ')
                .trim();
        }

        async function handleFile(file) {
            if (!file.name.endsWith('.epub')) {
                showStatus(t.errorFormat, 'error');
                return;
            }

            originalFilename = file.name;
            uploadButton.textContent = t.btnProcessing;
            uploadButton.classList.add('processing');
            showStatus(t.statusProcessing);

            try {
                const zip = await JSZip.loadAsync(file);
                const modifiedZip = new JSZip();
                globalFootnotes.clear();
                
                const mimetypeEntry = zip.file('mimetype');
                if (mimetypeEntry) {
                    const content = await mimetypeEntry.async('string');
                    modifiedZip.file('mimetype', content, { compression: 'STORE' });
                }
                
                zip.forEach((path, entry) => {
                    if (path.startsWith('META-INF/') && !entry.dir) {
                        modifiedZip.file(path, entry.async('string'));
                    }
                });
                
                showStatus(t.statusSearching);
                
                const allFiles = [];
                zip.forEach((relativePath, zipEntry) => {
                    if (!zipEntry.dir) {
                        allFiles.push({ relativePath, zipEntry });
                    }
                });
                
                for (const { relativePath, zipEntry } of allFiles) {
                    if (/\.(x?html?)$/i.test(relativePath)) {
                        const content = await zipEntry.async('string');
                        if (content.includes('Примечания') || content.includes('ПРИМЕЧАНИЯ') || 
                            content.includes('Примечание') || content.includes('Notes') || 
                            content.includes('NOTES')) {
                            extractFootnotes(content, relativePath);
                        }
                    }
                }
                
                showStatus(t.statusFound.replace('{count}', globalFootnotes.size));
                
                let totalReplacements = 0;
                
                for (const { relativePath, zipEntry } of allFiles) {
                    if (/\.(x?html?)$/i.test(relativePath)) {
                        const content = await zipEntry.async('string');
                        const { modifiedContent, replacements } = replaceFootnoteLinks(content);
                        totalReplacements += replacements;
                        modifiedZip.file(relativePath, modifiedContent);
                    } else {
                        modifiedZip.file(relativePath, zipEntry.async('arraybuffer'));
                    }
                }
                
                showStatus(t.statusCreating);
                
                processedBlob = await modifiedZip.generateAsync({ 
                    type: 'blob',
                    mimeType: 'application/epub+zip'
                });
                
                uploadButton.textContent = t.btnDownload;
                uploadButton.classList.remove('processing');
                showStatus(t.statusDone.replace('{count}', totalReplacements));
                
            } catch (error) {
                console.error('Error:', error);
                uploadButton.textContent = t.btnUpload;
                uploadButton.classList.remove('processing');
                processedBlob = null;
                showStatus(t.errorGeneric.replace('{message}', error.message), 'error');
            }
        }

        function extractFootnotes(html, filename) {
            const spanPattern = /<span[^>]+id=["']([^"']+)["'][^>]*>([\s\S]*?)<\/span>/gi;
            let match;
            
            while ((match = spanPattern.exec(html)) !== null) {
                const id = match[1];
                const content = match[2];
                
                const textMatch = content.match(/<\/div>([\s\S]*?)$/i);
                if (textMatch) {
                    let text = stripHtmlTags(textMatch[1]);
                    text = text.replace(/^\s*\d+\s*\.?\s*/, '').trim();
                    
                    if (text.length > 0) {
                        globalFootnotes.set(id, text);
                        globalFootnotes.set(`${filename}#${id}`, text);
                    }
                }
            }
        }

        function replaceFootnoteLinks(html) {
            let modifiedContent = html;
            let replacements = 0;
            
            const linkPattern = /<a\s+([^>]*href=["']([^"']*#([^"']+))["'][^>]*)>([^<]*)<\/a>/gi;
            
            modifiedContent = modifiedContent.replace(linkPattern, (fullMatch, attrs, href, anchorId, linkText) => {
                let footnoteText = globalFootnotes.get(anchorId);
                
                if (!footnoteText) {
                    footnoteText = globalFootnotes.get(href);
                }
                
                if (!footnoteText && href.startsWith('/')) {
                    footnoteText = globalFootnotes.get(href.substring(1));
                }
                
                if (footnoteText) {
                    replacements++;
                    footnoteText = expandNestedFootnotes(footnoteText);
                    return `<a ${attrs}>${linkText}</a> <i>[${footnoteText}]</i>`;
                }
                
                return fullMatch;
            });
            
            return { modifiedContent, replacements };
        }
        
        function expandNestedFootnotes(text) {
            const nestedLinkPattern = /<a\s+([^>]*href=["']([^"']*#([^"']+))["'][^>]*)>([^<]*)<\/a>/gi;
            
            return text.replace(nestedLinkPattern, (fullMatch, attrs, href, anchorId, linkText) => {
                let nestedFootnoteText = globalFootnotes.get(anchorId);
                
                if (!nestedFootnoteText) {
                    nestedFootnoteText = globalFootnotes.get(href);
                }
                
                if (!nestedFootnoteText && href.startsWith('/')) {
                    nestedFootnoteText = globalFootnotes.get(href.substring(1));
                }
                
                if (nestedFootnoteText) {
                    return `${linkText} [${nestedFootnoteText}]`;
                }
                
                return linkText;
            });
        }
        
        // Service Worker для PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(registration => console.log('SW registered'))
                    .catch(error => console.log('SW error:', error));
            });
        }
    </script>
</body>
</html>
